<?php

require_once __DIR__ . '/vendor/autoload.php';

use smtech\CanvasICSSync\Toolbox;
use smtech\ReflexiveCanvasLTI\LTI\ToolProvider;
use Battis\DataUtilities;

define('CONFIG_FILE', __DIR__ . '/config.xml');
define('CANVAS_INSTANCE_URL', 'canvas_instance_url');

@session_start(); // TODO I don't feel good about suppressing warnings

/* prepare the toolbox */
if (empty($_SESSION[Toolbox::class])) {
    $_SESSION[Toolbox::class] =& Toolbox::fromConfiguration(CONFIG_FILE);
}
$toolbox =& $_SESSION[Toolbox::class];
$toolbox->smarty_prependTemplateDir(__DIR__ . '/templates', basename(__DIR__));
$toolbox->smarty_assign([
    'category' => DataUtilities::titleCase(preg_replace('/[\-_]+/', ' ', basename(__DIR__)))
]);

/* set the Tool Consumer's instance URL, if present */
if (empty($_SESSION[CANVAS_INSTANCE_URL]) &&
    !empty($_SESSION[ToolProvider::class]['canvas']['api_domain'])
) {
    $_SESSION[CANVAS_INSTANCE_URL] = 'https://' . $_SESSION[ToolProvider::class]['canvas']['api_domain'];
}

/* argument values for sync */
define('SCHEDULE_ONCE', 'once');
define('SCHEDULE_WEEKLY', 'weekly');
define('SCHEDULE_DAILY', 'daily');
define('SCHEDULE_HOURLY', 'hourly');
define('SCHEDULE_CUSTOM', 'custom');

define('LOCAL_TIMEZONE', 'US/Eastern'); // TODO:0 Can we detect the timezone for the Canvas instance and use it? issue:18
define('SEPARATOR', '_'); // used when concatenating information in the cache database
define('CANVAS_TIMESTAMP_FORMAT', 'Y-m-d\TH:iP');
define('SYNC_TIMESTAMP_FORMAT', 'Y-m-d\TH:iP'); // same as CANVAS_TIMESTAMP_FORMAT, FWIW

define('VALUE_OVERWRITE_CANVAS_CALENDAR', 'overwrite');
define('VALUE_ENABLE_REGEXP_FILTER', 'enable_filter');

/* cache database tables */

/* calendars
    id                hash of ICS and Canvas pairing, generated by getPairingHash()
    ics_url            URL of ICS feed
    canvas_url        canonical URL for Canvas object
    synced            sync identification, generated by getSyncTimestamp()
    modified        timestamp of last modificiation of the record
*/

/* events
    id                    auto-incremented cache record id
    calendar            pair hash for cached calendar, generated by getPairingHash()
    calendar_event[id]    Canvas ID of calendar event
    event_hash            hash of cached event data from previous sync
    synced                sync identification, generated by getSyncTimestamp()
    modified            timestamp of last modification of the record
*/

/* schedules
    id            auto-incremented cache record id
    calendar    pair hash for cached calendar, generated by getPairingHash()
    crontab        crontab data for scheduled synchronization
    synced        sync identification, generated by getSyncTimestamp()
    modified    timestamp of last modification of the record
*/

function postMessage($subject, $body, $flag = NotificationMessage::INFO)
{
    global $toolbox;
    if (php_sapi_name() != 'cli') {
        $toolbox->smarty_addMessage($subject, $body, $flag);
    } else {
        $logEntry = "[$flag] $subject: $body";
        $toolbox->log($logEntry);
    }
}

/**
 * Generate a unique ID to identify this particular pairing of ICS feed and
 * Canvas calendar
 **/
function getPairingHash($icsUrl, $canvasContext)
{
    global $metadata;
    return md5($icsUrl . $canvasContext . $metadata['CANVAS_INSTANCE_URL']);
}

$FIELD_MAP = array(
    'calendar_event[title]' => 'SUMMARY',
    'calendar_event[description]' => 'DESCRIPTION',
    'calendar_event[start_at]' => array(
        0 => 'X-CURRENT-DTSTART',
        1 => 'DTSTART'
    ),
    'calendar_event[end_at]' => array(
        0 => 'X-CURRENT-DTEND',
        1 => 'DTEND'
    ),
    'calendar_event[location_name]' => 'LOCATION'
);

/**
 * Generate a hash of this version of an event to cache in the database
 **/
function getEventHash($event)
{
    global $FIELD_MAP;
    $blob = '';
    foreach ($FIELD_MAP as $field) {
        if (is_array($field)) {
            foreach ($field as $option) {
                if (!empty($property = $event->getProperty($option))) {
                    $blob .= serialize($property);
                    break;
                }
            }
        } else {
            if (!empty($property = $event->getProperty($field))) {
                $blob .= serialize($property);
            }
        }
    }
    return md5($blob);
}

/**
 * Generate a unique identifier for this synchronization pass
 **/
$SYNC_TIMESTAMP = null;
function getSyncTimestamp()
{
    global $SYNC_TIMESTAMP;
    if ($SYNC_TIMESTAMP) {
        return $SYNC_TIMESTAMP;
    } else {
        $timestamp = new DateTime();
        $SYNC_TIMESTAMP = $timestamp->format(SYNC_TIMESTAMP_FORMAT) . SEPARATOR .
            md5((php_sapi_name() == 'cli' ? 'cli' : $_SERVER['REMOTE_ADDR']) . time());
        return $SYNC_TIMESTAMP;
    }
}
